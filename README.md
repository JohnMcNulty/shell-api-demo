- [Shell API technical test overview](#shell-api-technical-test-overview)
  - [AWS website deployment / Source code](#aws-website-deployment--source-code)
  - [Assumptions](#assumptions)
  - [Packages used](#packages-used)
    - [web](#web)
    - [dotnet core API service](#dotnet-core-api-service)
  - [Web implementation](#web-implementation)
    - [Main application components](#main-application-components)
    - [Other](#other)
  - [dotnet core API service implementation](#dotnet-core-api-service-implementation)
    - [Data Layer](#data-layer)
    - [Service layer](#service-layer)
    - [ASP.NET Web API](#aspnet-web-api)
  - [Caveats & Risks](#caveats--risks)

<br /><br /><br />

# Shell API technical test overview

## AWS website deployment / Source code

Application has been deployed to AWS Amplify and is available here: https://master.d32wii2sjje0ac.amplifyapp.com/

Source code:
- `Web` :: https://github.com/JohnMcNulty/shell-api-demo/
- `dotnet core API` :: https://github.com/JohnMcNulty/Shell-API-dotnet-core-service
  

<br /><br />

## Assumptions

I have made an assumption from page 4 of the slides: _"For each file, calculate the minimum, maximum and median values ... Distribute the data via an API based on Date (no time), Meter and Data Type”_

I am assuming that this is required for each unique Date/Meter/DataType across all the data. Obviously, in the ‘real world’ I would ask for clarification on this assumption from the business sponsor.

<br /><br />

## Packages used 

The following npm and nuget packages have been used:

### web

Application has been created using [create-react-app](https://reactjs.org/docs/create-a-new-react-app.html#create-react-app) as a base.

- **react-bootstrap** : styling
- **plotly** : charting
- **moment** : formatting date labels (`Energy values by date` chart)
- **prettier**: code formatting
- **miragejs**: mock API - this takes the data generated by the [Shell API - dotnet core service](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service) and stores locally (see `api/server.js`)

### dotnet core API service

- **CsvHelper** : converts source flat file data to class objects
- **LinqStatistics** : used for median calculation across each resultset

---
<br /><br /><br />

## Web implementation

    * Represent the results in a simple UI (graphs, charts or other ways)

A ReactJS app (created from `create-react-app` npx package runner). Application data is self contained and accessed via a mock API. <br /><br />


### Main application components

Contains main 'connected' component (`EnergyMain`), calls API passes & props to child components.

|  Component name |  Purpose  | Comments  | 
|---|---|---|
| `EnergyMain` | Main **connected** parent component   |  Contains hook to call (mock) API on request type change (i.e. data by Date, by Energy Type, by Meter ) <br /> Handles click event from child control panel <br /> Passes props to children | 
| `EnergyHeader`  | Renders static header  | Child component <br />  |  
| `EnergyControlPanel` |  Renders user inputs (i.e. buttons) | Child component <br />Renders `Date`, `Meter`, `Type` buttons<br /> useState hooks tracks current selection (and highlights in UI `render`) <br /> Calls prop `onClick` func (supplied by parent component) |   
| `EnergyChart`  |  Renders data in plotly chart  | Child component <br />Component contains hook that fires call to `buildChart` on chartData change <br /> Chart data is sorted, sanitized & formatted on changes to request type (see `buildChart` func) <br /> `buildChart` accepts optional `fnFormatLabel` func to format x-axis labels  |   

### Other 

/src/index.js

- Creates mock api server [link](https://github.com/JohnMcNulty/shell-api-demo/blob/master/src/index.js#L11)
- adds bootstrap css [link](https://github.com/JohnMcNulty/shell-api-demo/blob/master/src/index.js#L8)

/src/App.js

- wraps main 'entry' component `EnergyMain`

---
<br /><br /><br />

## dotnet core API service implementation

Created a dotnet core API with standard Service-Orientated-Architecture containing Service and Repository layers. 

Postman collection for localhost API testing is [here](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service/blob/master/Shell%20API.postman_collection.json).


### Data Layer

    * Ingests data files and stores the raw data

- In a 'real world' application with process would be handeld via an SSIS package (or similar) to load the flat files into staging tables within a database.

- The repository layer's sole purpose is to read the raw flat files and returns a `List<T>` of either `LpRow` or `TouRow` objects  (obviously, in the real world this dataset would come from a DB call via a stored procedure). See [FlatFileDataLoaderGeneric.cs](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service/blob/master/ShellApiRepository/Implementation/FlatFileDataLoaderGeneric.cs).

  - I've made this class **generic** to handle the variances between the 'LP...' and 'TOU...' files. Using the `CsvHelper` nuget package for simple reading of the files.

  - Models contain mapping helper classes (part of `CsvHelper -> ClassMap` nuget package) which assist with formatting dates (and generally make field mapping easier). [LINK](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service/blob/master/ShellModels/RawData/LpRow.cs#L32)

  - FlatFileDataLoaderGeneric.cs implements the `IDataLoaderGeneric` interface. Therefore, another concrete implementation of this interface could be created that points to a datastore but would not affect the calling Service layer.

### Service layer

    * Transform the data to produce an aggregated result

- Contains [SanitizedEnergyRecords.cs](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service/blob/master/ShellApiService/Implementation/SanitizedEnergyRecords.cs) that transforms raw data from `List<LpRow>` or `List<TouRow>` to a unified List (see `GetMergedData()`).

- Methods to get data by request type e.g. `GetDataByMeter()`. These are called by the Web API layer and return a list of `IList<ReportingUnit>` containing the min/max/median calculations by Meter/EnergyDataType/Date.


### ASP.NET Web API

    * Distribute the aggregated result as an API
    * Distribute the data via an API based on Date (no time), Meter and Data Type



- `EnergyRecordsController.cs` contains endpoints for each required type, endpoints call service layer and returns results as JSON.
- `Startup.cs` configured to dependency inject repository and service layers. [Link](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service/blob/master/ShellApi/Startup.cs#L33)
- Serialization options configured to *return data in camel case* and *remove null values* from `ReportingUnit` objects. [Link](https://github.com/JohnMcNulty/Shell-API-dotnet-core-service/blob/master/ShellApi/Controllers/EnergyRecordsController.cs#L20). 


---
<br /><br />

## Caveats & Risks

In a real world application I would introduce Unit Testing, Security, Logging and more robust error handling. This solution is very bare bones and follows only a _happy path!_. If you would like me to introduce these features (or discuss how I would implement them) then please let me know.
